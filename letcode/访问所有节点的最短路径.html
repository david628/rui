<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">
        body {
            margin: 0;
        }

    </style>
</head>
<body style="background: #eee;">
<script type="text/javascript">
    // 847. 访问所有节点的最短路径
    // 给出 graph 为有 N 个节点（编号为 0, 1, 2, ..., N-1）的无向连通图。 

    // graph.length = N，且只有节点 i 和 j 连通时，j != i 在列表 graph[i] 中恰好出现一次。

    // 返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。

    

    // 示例 1：

    // 输入：[[1,2,3],[0],[0],[0]]
    // 输出：4
    // 解释：一个可能的路径为 [1,0,2,0,3]
    // 示例 2：

    // 输入：[[1],[0,2,4],[1,3,4],[2],[1,2]]
    // 输出：4
    // 解释：一个可能的路径为 [0,1,4,2,3]
    var shortestPathLength = function(graph) {
        if(!graph) {
            return 0;
        }
        let vised = {};
        let queue = [graph];
        let step = 0;
        let rs = [];
        while(queue.length) {
            let len = queue.length;
            for(let i = 0; i < len; i++) {
                let cur = queue.shift();
                for(let j = 0; j < cur.length; j++) {
                    
                    if(!vised[cur[j]]) {
                        vised[cur[j]] = true;
                        queue.push(cur[j]);
                    }
                }
                vised[cur] = true;
            }
            step++;
        }
        return rs;
    };
        

    console.log(shortestPathLength([[1,2,3],[0],[0],[0]]));
</script>
</body>
</html>
